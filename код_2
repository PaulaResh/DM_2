# ЗАДАНИЕ №2

# читаю данные из файла
with open('20_2.txt', 'r') as f:
    lines = f.readlines()
    n = int(lines[0].strip())
    matrix = []
    for i in range(1, n + 1):
        row = list(map(int, lines[i].split()))
        matrix.append(row)


adj = [[] for _ in range(n)]
degrees = [0] * n

for i in range(n):
    for j in range(i + 1, n):
        if matrix[i][j] == 1:
            adj[i].append(j)
            adj[j].append(i)
            degrees[i] += 1
            degrees[j] += 1

# проверяем связность графа (DFS)
visited = [False] * n
stack = [0]
visited[0] = True
visited_count = 1

while stack:
    v = stack.pop()
    for neighbor in adj[v]:
        if not visited[neighbor]:
            visited[neighbor] = True
            stack.append(neighbor)
            visited_count += 1

# если граф несвязный, то нельзя пройти все ходы
if visited_count != n:
    print('НЕТ')

else:
    # считаем количество вершин с нечетными степенями
    odd_vertices = 0
    for i in range(n):
        if degrees[i] % 2 == 1:
            odd_vertices += 1

    if odd_vertices == 0:
        # эйлеров цикл-можно вернуться в начальную точку
        print('ДА')
        print('ВЕРНУТЬСЯ')

        start_vertex = 0

        adj_copy = [neighbors[:] for neighbors in adj]
        path = []
        stack = [start_vertex]

        while stack:
            v = stack[-1]
            if adj_copy[v]:
                u = adj_copy[v][0]
                adj_copy[v].remove(u)
                adj_copy[u].remove(v)
                stack.append(u)
            else:
                path.append(stack.pop())
        path.reverse()

        path_str = ' '.join(str(x + 1) for x in path)
        print(path_str)

    elif odd_vertices == 2:
        print('ДА')
        print('НЕ ВЕРНУТЬСЯ')

        odd_vertices_list = []
        for i in range(n):
            if degrees[i] % 2 == 1:
                odd_vertices_list.append(i)

        start_vertex = odd_vertices_list[0]

        # алгоритм для построения эйлерова пути
        adj_copy = [neighbors[:] for neighbors in adj]
        path = []
        stack = [start_vertex]

        while stack:
            v = stack[-1]
            if adj_copy[v]:
                u = adj_copy[v][0]
                adj_copy[v].remove(u)
                adj_copy[u].remove(v)
                stack.append(u)
            else:
                path.append(stack.pop())

        path.reverse()

        path_str = ' '.join(str(x + 1) for x in path)
        print(path_str)

    else:
        # нельзя пройти все ребра по одному разу
        print('НЕТ')
